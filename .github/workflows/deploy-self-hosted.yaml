name: Build and Deploy (Self-Hosted Runner)
on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Also allow manual trigger
    inputs:
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean
      skip_deploy:
        description: 'Skip deployment (build only)'
        required: false
        default: false
        type: boolean

jobs:
  build-and-deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for SonarQube analysis

      # Read VERSION file for semantic versioning
      - name: Read VERSION
        id: version
        run: |
          VERSION=$(cat VERSION | tr -d '[:space:]')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Deployment Version: $VERSION"
      
      # ===== SonarQube Analysis with Timing Metrics =====
      - name: SonarQube Analysis with Timing Metrics
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          # Skip if no credentials
          if [ -z "$SONAR_TOKEN" ] || [ -z "$SONAR_HOST_URL" ]; then
            echo "‚ö†Ô∏è  SonarQube credentials not configured - skipping"
            exit 0
          fi
          
          # Function to send timing metric to Datadog
          send_timing() {
            local metric=$1
            local duration=$2
            local tags=$3
            if command -v nc &> /dev/null; then
              echo "${metric}:${duration}|ms|${tags}" | nc -u -w1 127.0.0.1 8125 2>/dev/null || true
              echo "üìä Sent metric: ${metric}=${duration}ms"
            fi
          }
          
          echo "üîç Starting SonarQube analysis..."
          TOTAL_START=$(date +%s)
          
          # Phase 1: Preparation
          echo "::group::üìã Phase 1: Project Preparation"
          PREP_START=$(date +%s)
          
          FILES=$(find . -name "*.py" -not -path "./venv/*" -not -path "./.git/*" | wc -l)
          LINES=$(find . -name "*.py" -not -path "./venv/*" -not -path "./.git/*" -exec wc -l {} + | tail -1 | awk '{print $1}' || echo "0")
          echo "Found $FILES Python files with $LINES lines"
          
          PREP_END=$(date +%s)
          PREP_DURATION=$((PREP_END - PREP_START))
          send_timing "sonarqube.phase.preparation" "$((PREP_DURATION * 1000))" "#project:demo-fastapi"
          echo "::endgroup::"
          
          # Phase 2: Code Analysis
          echo "::group::üîç Phase 2: Code Analysis"
          SCAN_START=$(date +%s)
          
          docker run --rm \
            -e SONAR_HOST_URL="$SONAR_HOST_URL" \
            -e SONAR_TOKEN="$SONAR_TOKEN" \
            -v "$(pwd):/usr/src" \
            sonarsource/sonar-scanner-cli \
            -Dsonar.projectKey=quickstark_demo-fastapi_6ba235ba-ff96-459d-8607-919121b2ad98 \
            -Dsonar.sources=main.py,src \
            -Dsonar.tests=tests \
            -Dsonar.language=py \
            -Dsonar.python.version=3.9,3.10,3.11,3.12 \
            -Dsonar.sourceEncoding=UTF-8 || {
              echo "‚ö†Ô∏è  SonarQube scan failed - continuing deployment"
              exit 0
            }
          
          SCAN_END=$(date +%s)
          SCAN_DURATION=$((SCAN_END - SCAN_START))
          send_timing "sonarqube.phase.analysis" "$((SCAN_DURATION * 1000))" "#project:demo-fastapi"
          echo "Analysis took ${SCAN_DURATION} seconds"
          echo "::endgroup::"
          
          # Phase 3: Metrics Collection
          echo "::group::üìä Phase 3: Metrics Collection"
          METRICS_START=$(date +%s)
          sleep 3  # Wait for processing
          
          PROJECT="quickstark_demo-fastapi_6ba235ba-ff96-459d-8607-919121b2ad98"
          METRICS=$(curl -s -u "$SONAR_TOKEN:" \
            "$SONAR_HOST_URL/api/measures/component?component=${PROJECT}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density" \
            2>/dev/null) || METRICS="{}"
          
          BUGS=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="bugs") | .value // "0"' 2>/dev/null || echo "0")
          VULNS=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="vulnerabilities") | .value // "0"' 2>/dev/null || echo "0")
          SMELLS=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="code_smells") | .value // "0"' 2>/dev/null || echo "0")
          COVERAGE=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="coverage") | .value // "0"' 2>/dev/null || echo "0")
          
          METRICS_END=$(date +%s)
          METRICS_DURATION=$((METRICS_END - METRICS_START))
          send_timing "sonarqube.phase.metrics" "$((METRICS_DURATION * 1000))" "#project:demo-fastapi"
          
          # Send quality metrics
          if command -v nc &> /dev/null; then
            echo "sonarqube.bugs:$BUGS|g|#project:demo-fastapi,branch:${{ github.ref_name }}" | nc -u -w1 127.0.0.1 8125 2>/dev/null || true
            echo "sonarqube.vulnerabilities:$VULNS|g|#project:demo-fastapi,branch:${{ github.ref_name }}" | nc -u -w1 127.0.0.1 8125 2>/dev/null || true
            echo "sonarqube.code_smells:$SMELLS|g|#project:demo-fastapi,branch:${{ github.ref_name }}" | nc -u -w1 127.0.0.1 8125 2>/dev/null || true
            echo "sonarqube.coverage:$COVERAGE|g|#project:demo-fastapi,branch:${{ github.ref_name }}" | nc -u -w1 127.0.0.1 8125 2>/dev/null || true
          fi
          
          echo "Bugs: $BUGS, Vulnerabilities: $VULNS, Code Smells: $SMELLS, Coverage: $COVERAGE%"
          echo "::endgroup::"
          
          # Phase 4: Quality Gate
          echo "::group::‚úÖ Phase 4: Quality Gate Check"
          QG_START=$(date +%s)
          
          QG_STATUS=$(curl -s -u "$SONAR_TOKEN:" \
            "$SONAR_HOST_URL/api/qualitygates/project_status?projectKey=${PROJECT}" \
            | jq -r '.projectStatus.status' 2>/dev/null) || QG_STATUS="UNKNOWN"
          
          QG_END=$(date +%s)
          QG_DURATION=$((QG_END - QG_START))
          send_timing "sonarqube.phase.quality_gate" "$((QG_DURATION * 1000))" "#project:demo-fastapi,status:$QG_STATUS"
          
          if [ "$QG_STATUS" = "OK" ]; then
            echo "‚úÖ Quality Gate: PASSED"
          elif [ "$QG_STATUS" = "ERROR" ]; then
            echo "‚ùå Quality Gate: FAILED (continuing anyway)"
          else
            echo "‚ö†Ô∏è  Quality Gate: $QG_STATUS"
          fi
          echo "::endgroup::"
          
          # Total timing
          TOTAL_END=$(date +%s)
          TOTAL_DURATION=$((TOTAL_END - TOTAL_START))
          send_timing "sonarqube.total" "$((TOTAL_DURATION * 1000))" "#project:demo-fastapi"
          
          echo "::notice title=SonarQube Complete::Analysis completed in ${TOTAL_DURATION} seconds (Bugs: $BUGS, Vulnerabilities: $VULNS, Coverage: $COVERAGE%)"
        continue-on-error: true
      
      # ===== System Information =====
      - name: System Information
        run: |
          echo "=== System Information ==="
          echo "Hostname: $(hostname)"
          echo "User: $(whoami)"
          echo "Working Directory: $(pwd)"
          echo "OS: $(uname -a)"
          echo "=========================="
      
      - name: Check Available Tools
        run: |
          echo "=== Checking Available Tools ==="
          
          # Check Python
          if command -v python3 &> /dev/null; then
            echo "‚úì Python3: $(python3 --version)"
          else
            echo "‚úó Python3 not found"
          fi
          
          # Check Docker
          if command -v docker &> /dev/null; then
            echo "‚úì Docker: $(docker --version)"
            if docker ps &> /dev/null; then
              echo "  ‚úì Docker daemon accessible"
            else
              echo "  ‚úó Docker daemon not accessible (might need socket mount)"
            fi
          else
            echo "‚úó Docker not found"
          fi
          
          # Check Docker Compose
          if command -v docker-compose &> /dev/null; then
            echo "‚úì Docker Compose: $(docker-compose --version)"
          else
            echo "‚úó Docker Compose not found"
          fi
          
          # Check curl and other tools
          command -v curl &> /dev/null && echo "‚úì curl available" || echo "‚úó curl not found"
          command -v jq &> /dev/null && echo "‚úì jq available" || echo "‚úó jq not found"
          command -v nc &> /dev/null && echo "‚úì netcat available" || echo "‚úó netcat not found"
          
          echo "=========================="
      
      # ===== Testing =====
      - name: Setup Python Environment (if available)
        if: ${{ !inputs.skip_tests || github.event_name == 'push' }}
        run: |
          if command -v python3 &> /dev/null; then
            echo "Setting up Python environment..."
            python3 -m venv venv || true
            source venv/bin/activate || true
            pip install --upgrade pip || true
            pip install -r requirements.txt || true
          else
            echo "Python not available, skipping Python setup"
          fi
      
      - name: Run Tests in Container
        if: ${{ !inputs.skip_tests || github.event_name == 'push' }}
        run: |
          if command -v docker &> /dev/null && docker ps &> /dev/null; then
            echo "Running tests in Docker container..."
            echo "Current directory: $(pwd)"
            echo "Checking for requirements.txt..."
            if [ -f "requirements.txt" ]; then
              echo "‚úì Found requirements.txt"
            else
              echo "‚úó requirements.txt not found in $(pwd)"
              ls -la
            fi

            docker run --rm \
              -v "$(pwd)":/app \
              -w /app \
              -e MONGO_CONN=localhost \
              -e MONGO_USER=testuser \
              -e MONGO_PW=testpass \
              -e OPENAI_API_KEY=dummy-key-for-testing \
              -e SES_REGION=us-east-1 \
              -e SES_FROM_EMAIL=test@example.com \
              -e NOTION_API_KEY=dummy-key-for-testing \
              -e NOTION_DATABASE_ID=dummy-key-for-testing \
              -e AMAZON_KEY_ID=dummy-key-for-testing \
              -e AMAZON_KEY_SECRET=dummy-key-for-testing \
              -e AMAZON_S3_BUCKET=dummy-bucket-for-testing \
              -e BUG_REPORT_EMAIL=test@example.com \
              python:3.12-slim bash -c "ls -la && pip install -r requirements.txt && pytest -v" || echo "‚ö†Ô∏è  Tests failed or were skipped"
          elif command -v python3 &> /dev/null; then
            echo "Running tests with local Python..."
            source venv/bin/activate || true
            pytest -v || echo "Tests failed or skipped"
          else
            echo "‚ö†Ô∏è  Cannot run tests - no Python or Docker available"
          fi
      
      # ===== Build and Push =====
      - name: Build Docker Image
        id: docker_build
        run: |
          if command -v docker &> /dev/null && docker ps &> /dev/null; then
            echo "Building Docker image..."
            
            # Login to Docker Hub
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login --username "${{ secrets.DOCKERHUB_USER }}" --password-stdin
            
            # Build the image
            docker build -t quickstark/api-images:latest .
            
            # Tag with commit SHA
            docker tag quickstark/api-images:latest quickstark/api-images:${{ github.sha }}
            
            # Push to Docker Hub
            docker push quickstark/api-images:latest
            docker push quickstark/api-images:${{ github.sha }}
            
            echo "‚úÖ Docker image built and pushed successfully"
          else
            echo "‚ùå Docker not available or not accessible"
            echo "If your runner is containerized, ensure Docker socket is mounted:"
            echo "  -v /var/run/docker.sock:/var/run/docker.sock"
            exit 1
          fi
      
      # ===== Deployment =====
      - name: Deploy to Local Docker
        if: ${{ !inputs.skip_deploy && steps.docker_build.outcome == 'success' }}
        run: |
          echo "=== Deploying to Local Docker on GMKTec ==="
          
          # Stop and remove existing container
          echo "Stopping existing container..."
          docker stop images-api 2>/dev/null || echo "No existing container to stop"
          docker rm -f images-api 2>/dev/null || echo "No existing container to remove"
          
          # Clean up old images to save space
          echo "Cleaning up old images..."
          docker image prune -f || true
          
          # Pull the latest image (already pushed to Docker Hub)
          echo "Pulling latest image from Docker Hub..."
          docker pull quickstark/api-images:latest
          
          # Run new container with production configuration
          echo "Starting new container..."
          docker run -d \
            --name images-api \
            --restart unless-stopped \
            -p 9000:8080 \
            --add-host=host.docker.internal:host-gateway \
            -e DD_SERVICE="${{ secrets.DD_SERVICE }}" \
            -e DD_ENV="${{ secrets.DD_ENV }}" \
            -e DD_VERSION="${{ steps.version.outputs.version }}" \
            -e DD_AGENT_HOST="${{ secrets.DD_AGENT_HOST || 'host.docker.internal' }}" \
            -e DD_PROFILING_ENABLED=true \
            -e DD_PROFILING_TIMELINE_ENABLED=true \
            -e DD_DBM_PROPAGATION_MODE=full \
            -e PGHOST="${{ secrets.PGHOST }}" \
            -e PGPORT="${{ secrets.PGPORT }}" \
            -e PGDATABASE="${{ secrets.PGDATABASE }}" \
            -e PGUSER="${{ secrets.PGUSER }}" \
            -e PGPASSWORD="${{ secrets.PGPASSWORD }}" \
            -e SQLSERVER_ENABLED="${{ secrets.SQLSERVER_ENABLED || 'true' }}" \
            -e SQLSERVERHOST="${{ secrets.SQLSERVERHOST }}" \
            -e SQLSERVERPORT="${{ secrets.SQLSERVERPORT }}" \
            -e SQLSERVERUSER="${{ secrets.SQLSERVERUSER }}" \
            -e SQLSERVERPW="${{ secrets.SQLSERVERPW }}" \
            -e SQLSERVERDB="${{ secrets.SQLSERVERDB }}" \
            -e OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            -e DD_API_KEY="${{ secrets.DD_API_KEY }}" \
            -e DD_APP_KEY="${{ secrets.DD_APP_KEY }}" \
            -e SES_REGION="${{ secrets.SES_REGION }}" \
            -e SES_FROM_EMAIL="${{ secrets.SES_FROM_EMAIL }}" \
            -e NOTION_API_KEY="${{ secrets.NOTION_API_KEY }}" \
            -e NOTION_DATABASE_ID="${{ secrets.NOTION_DATABASE_ID }}" \
            -e AMAZON_KEY_ID="${{ secrets.AMAZON_KEY_ID }}" \
            -e AMAZON_KEY_SECRET="${{ secrets.AMAZON_KEY_SECRET }}" \
            -e AMAZON_S3_BUCKET="${{ secrets.AMAZON_S3_BUCKET }}" \
            -e MONGO_CONN="${{ secrets.MONGO_CONN }}" \
            -e MONGO_USER="${{ secrets.MONGO_USER }}" \
            -e MONGO_PW="${{ secrets.MONGO_PW }}" \
            -e BUG_REPORT_EMAIL="${{ secrets.BUG_REPORT_EMAIL }}" \
            quickstark/api-images:latest
          
          # Wait for container to start
          echo "Waiting for container to start..."
          sleep 10
          
          # Check container status
          echo "Container status:"
          docker ps | grep images-api || echo "Container not found in ps output"
          
          # Check health endpoint
          echo "Checking health endpoint..."
          if curl -f http://localhost:9000/health 2>/dev/null; then
            echo "‚úÖ Health check passed - API is running on port 9000"
          elif curl -f http://localhost:9000/ 2>/dev/null; then
            echo "‚úÖ Root endpoint accessible on port 9000"
          else
            echo "‚ö†Ô∏è  Health check failed - checking container logs..."
            docker logs --tail 50 images-api
          fi
          
          echo "‚úÖ Deployment complete!"
          echo "Application is running at: http://localhost:9000"
      
      # ===== Post-Deployment =====
      - name: Deployment Notification
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Deployment successful!"
            echo "Commit: ${{ github.sha }}"
            echo "Branch: ${{ github.ref_name }}"
            echo "Actor: ${{ github.actor }}"
          else
            echo "‚ùå Deployment failed!"
            echo "Check the logs above for details"
          fi
      
      # Install Node.js and datadog-ci for containerized runners
      - name: Setup Node.js for Datadog CI
        if: success()
        run: |
          echo "Checking for Node.js and npm..."
          if ! command -v node &> /dev/null; then
            echo "Node.js not found, attempting installation..."
            if command -v apt-get &> /dev/null; then
              curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
              apt-get install -y nodejs
            elif command -v apk &> /dev/null; then
              apk add --no-cache nodejs npm
            else
              echo "‚ö†Ô∏è  Could not install Node.js automatically"
            fi
          else
            echo "‚úì Node.js already installed: $(node --version)"
          fi

          if ! command -v npm &> /dev/null; then
            echo "‚ùå npm not available"
          else
            echo "‚úì npm available: $(npm --version)"
          fi

      - name: Mark Deployment in Datadog
        if: success()
        continue-on-error: true
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
        run: |
          # Get short SHA for reference
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"

          echo "üì¶ Marking deployment with version: ${{ steps.version.outputs.version }}"
          echo "üîñ Git SHA: $SHORT_SHA"
          echo ""

          # Check if DD_API_KEY is set
          if [ -z "$DD_API_KEY" ]; then
            echo "‚ùå ERROR: DD_API_KEY is not set in secrets"
            echo "‚ö†Ô∏è  Deployment marking skipped - please configure DD_API_KEY"
            exit 0
          fi

          DEPLOYMENT_MARKED=false

          # First try with existing datadog-ci if available
          if command -v datadog-ci &> /dev/null; then
            echo "‚úì Found datadog-ci in PATH"
            if datadog-ci deployment mark \
              --env "${{ secrets.DD_ENV }}" \
              --service "${{ secrets.DD_SERVICE }}" \
              --revision "${{ steps.version.outputs.version }}" \
              --tags "deployment_method:self_hosted" \
              --tags "repository:${{ github.repository }}" \
              --tags "branch:${{ github.ref_name }}" \
              --tags "git_sha:$SHORT_SHA" \
              --no-fail; then
              DEPLOYMENT_MARKED=true
              echo "‚úÖ Deployment marked successfully with datadog-ci"
            fi
          # Otherwise try to install it locally
          elif command -v npm &> /dev/null; then
            echo "‚úì Found npm, installing datadog-ci locally..."
            # Install locally to avoid permission issues
            if npm install @datadog/datadog-ci 2>&1; then
              echo "‚úì datadog-ci installed successfully"
              if [ -f "$(pwd)/node_modules/.bin/datadog-ci" ]; then
                echo "‚úì Found datadog-ci binary"
                if $(pwd)/node_modules/.bin/datadog-ci deployment mark \
                  --env "${{ secrets.DD_ENV }}" \
                  --service "${{ secrets.DD_SERVICE }}" \
                  --revision "${{ steps.version.outputs.version }}" \
                  --tags "deployment_method:self_hosted" \
                  --tags "repository:${{ github.repository }}" \
                  --tags "branch:${{ github.ref_name }}" \
                  --tags "git_sha:$SHORT_SHA" \
                  --no-fail; then
                  DEPLOYMENT_MARKED=true
                  echo "‚úÖ Deployment marked successfully with local datadog-ci"
                else
                  echo "‚ùå datadog-ci command failed"
                fi
              else
                echo "‚ùå datadog-ci binary not found after installation"
              fi
            else
              echo "‚ùå npm install failed"
            fi
          else
            echo "‚ùå Neither datadog-ci nor npm is available"
          fi

          if [ "$DEPLOYMENT_MARKED" = false ]; then
            echo ""
            echo "‚ö†Ô∏è  WARNING: Deployment was NOT marked in Datadog"
            echo ""
            echo "For containerized runners, consider one of these approaches:"
            echo "1. Build custom runner image with Node.js and datadog-ci pre-installed"
            echo "2. Install Node.js in the runner container startup script"
            echo "3. Use Datadog HTTP API instead (see documentation)"
            echo ""
          else
            echo ""
            echo "üéâ Deployment successfully marked in Datadog with version ${{ steps.version.outputs.version }}"
            echo ""
          fi
      
      - name: Post Checkout code
        run: |
          echo "Workflow complete"
      
      - name: Complete job
        run: |
          echo "All steps completed"